%% GetRobot
workspace = [-2 2 -1 4 0 3];
name = ('kinova');

L1 = Link('d',0.2848,'a',0,'alpha',-pi/2,'offset',0,'qlim',[deg2rad(-360),deg2rad(360)]);
L2 = Link('d',0.0054,'a',0.41,'alpha',-pi,'offset',-pi/2,'qlim',[deg2rad(-90),deg2rad(90)]);
L3 = Link('d',0.0064,'a',0,'alpha',-pi/2,'offset',-pi/2,'qlim',[deg2rad(-147.8),deg2rad(147.8)]);
L4 = Link('d',0.2084+.1059,'a',0,'alpha',-pi/2,'offset',0,'qlim',[deg2rad(-360),deg2rad(360)]);
L5 = Link('d',0,'a',0,'alpha',pi/2,'offset',0,'qlim',[deg2rad(-120.3),deg2rad(120.3)]);
L6 = Link('d',0.1059+.06153,'a',0,'alpha',0,'offset',0,'qlim',[deg2rad(-360),deg2rad(360)]);

kinova = SerialLink([L1 L2 L3 L4 L5 L6],'name',name);
kinova.base = transl(0,3,1);
q = [0 0 0 0 0 0];

kinova.plot(q0,'workspace',workspace,'scale',.5);

%% Determine if someone goes through red line

centerpnt = [-1,3,1];
side = 1;
plotOptions.plotFaces = true;
[vertex,faces,Normal] = RectangularPrism(centerpnt-side/2, centerpnt+side/2,plotOptions);
axis equal
Start = [1.6 0 .5];
End = [2.6 0 .5];
plot3([Start(1),End(1)],[Start(2),End(2)],[Start(3),End(3)],'r');
for faceIndex = 1:size(faces,1)
    vertOnPlane = vertex(faces(faceIndex,1)',:);
    [intersects,check]=LinePlaneIntersection(Normal(faceIndex,:),vertOnPlane,Start,End);
    if check == 1 && IsIntersectionPointInsideTriangle(intersects,vertex(faces(faceIndex,:)',:))
        disp('Unauthorized person on the area')
        plot3(intersects(1),intersects(2),intersects(3),'g*');
    end
end

%% Active Collision avoidance 
q0 = [0 0 0 0 0 0];
q1 = [-0.0015 -1.5708 -0.5828 -3.1413 1.9777 3.1429];
% %     q1 = kinova.ikcon(RedCan,q0);
x = 0;
y = 3;
z = 2.17;
fx = .15;
fz = .1;
qWaypoints = [q0 ; kinova.ikcon(transl(x,y,z),q0)];
[T,all] = kinova.fkine(qWaypoints(end,:));
for j = 1:6
    for i = 1 : size(all,3)-1
        for faceIndex = 1:size(faces,1)
            futureWaypoints = [qWaypoints ; kinova.ikcon(transl(x-fx,y,z-fz),qWaypoints(end,:))];
            [T,newall] = kinova.fkine(futureWaypoints(end,:));
            vertOnPlane = vertex(faces(faceIndex,1)',:);
            [intersects,check]=LinePlaneIntersection(Normal(faceIndex,:),vertOnPlane,newall(1:3,4,i)',newall(1:3,4,i+1)');
            if check == 1 && IsIntersectionPointInsideTriangle(intersects,vertex(faces(faceIndex,:)',:))
                disp('Avoiding Collision')
                y = y-.3;
                x= x+.3;
            end
        end
    end
    qWaypoints = [qWaypoints; kinova.ikcon(transl(x,y,z),qWaypoints(end,:))];
    x=x-fx;
    z =z-fz;
end
qWaypoints = [qWaypoints; kinova.ikcon(transl(x,y,1.1),q1)];
[T,all] = kinova.fkine(q1);
for i = 1 : size(all,3)-1
    for faceIndex = 1:size(faces,1)
        vertOnPlane = vertex(faces(faceIndex,1)',:);
        [intersects,check]=LinePlaneIntersection(Normal(faceIndex,:),vertOnPlane,all(1:3,4,i)',all(1:3,4,i+1)');
        if check == 1 && IsIntersectionPointInsideTriangle(intersects,vertex(faces(faceIndex,:)',:))
            disp('Cannot get to final destination, please clear the area')
            %uiwait
        end
    end
end
qWaypoints = [qWaypoints; q1];
qMatrix = InterpolateWaypointRadians(qWaypoints,deg2rad(5));
kinova.animate(qMatrix);

%% FineInterpolation

function qMatrix = FineInterpolation(q1,q2,maxStepRadians)
if nargin < 3
    maxStepRadians = deg2rad(1);
end

steps = 2;
while ~isempty(find(maxStepRadians < abs(diff(jtraj(q1,q2,steps))),1))
    steps = steps + 1;
end
qMatrix = jtraj(q1,q2,steps);
end
%% InterpolateWaypointRadians
% Given a set of waypoints, finely intepolate them
function qMatrix = InterpolateWaypointRadians(waypointRadians,maxStepRadians)
if nargin < 2
    maxStepRadians = deg2rad(1);
end

qMatrix = [];
for i = 1: size(waypointRadians,1)-1
    qMatrix = [qMatrix ; FineInterpolation(waypointRadians(i,:),waypointRadians(i+1,:),maxStepRadians)]; %#ok<AGROW>
end
end
%% IsIntersectionPointInsideTriangle
function result = IsIntersectionPointInsideTriangle(intersectP,triangleVerts)

u = triangleVerts(2,:) - triangleVerts(1,:);
v = triangleVerts(3,:) - triangleVerts(1,:);

uu = dot(u,u);
uv = dot(u,v);
vv = dot(v,v);

w = intersectP - triangleVerts(1,:);
wu = dot(w,u);
wv = dot(w,v);

D = uv * uv - uu * vv;

% Get and test parametric coords (s and t)
s = (uv * wv - vv * wu) / D;
if (s < 0.0 || s > 1.0)        % intersectP is outside Triangle
    result = 0;
    return;
end

t = (uv * wu - uu * wv) / D;
if (t < 0.0 || (s + t) > 1.0)  % intersectP is outside Triangle
    result = 0;
    return;
end

result = 1;                      % intersectP is in Triangle
end

